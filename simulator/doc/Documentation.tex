\documentclass[hidelinks,12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{float}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
}

\pagestyle{fancy}
\fancyhf{}
\chead{MIPS simulator with DRAM timing model}
\rfoot{\thepage}

\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[scale=0.5]{../../logo.png}\\[1.0cm]
    \Large INDIAN INSTITUTE OF TECHNOLOGY DELHI\\[1.0 cm]
    \LARGE COL216\\[0.1cm]
    \Large \underline{Report}\\
    \large \[Minor\]
    \LARGE \textbf{MIPS simulator with DRAM timing model}


    \rule{\textwidth}{0.2 mm} \\[0.1cm]
    \begin{abstract}
        A simulator is a software that emulates the actions of an entity without actually utilising the entity.
        Here we attempt to create a cross platform MIPS simulator that emulates all the hardware instructions supported by MIPS.
        This simulator takes as input a MIPS assembly program that translates it into instructions executed by MIPS.
        \\[0.1cm]
    \end{abstract}
    \rule{\textwidth}{0.2 mm} \\[0.1cm]
    \begin{flushright}

        \begin{tabular}{c c}
            \small {Harsh Agrawal} & \small {2019CS10431} \\
        \end{tabular}
    \end{flushright}
\end{titlepage}
\tableofcontents
\newpage

\section{Modules}
We implemented a simulator in \verb|C++| for executing MIPS instructions from input assembly code.The program was divided into three modules \verb|compiler| ,\verb|hardware|, and a \verb|DRAM| module.
These modules perform different functions as outlined below
\subsection{Compiler}
\begin{itemize}
    \item This module takes as input the assembly program and parses the tokens according to the syntax specifications of MIPS assembly programs.
    \item This module assembles the program into a sequence of instructions that can be executed according to the hardware specifications.
    \item It also generates appropriate syntax errors if an erreneous expression or an unidentified token is encountered.
    \item The compiler checks the encodibility of instructions into 4 bytes (without actually encoding it) using the size of operands involved.
\end{itemize}
\subsection{Hardware}
\begin{itemize}
    \item This module emulates a subset of instructions provided by MIPS. They are \verb|add, mul, sub, slt, addi, bne, beq, j, lw, sw|.
    \item The module maintains a record of all the register and memory values and modifies them according to the instruction specifications.
    \item It generates appropriate exceptions on performing prohibited actions like out of bounds memory access and reserved register access.
\end{itemize}

\subsection{DRAM}
\begin{itemize}
    \item This module implements the DRAM model in the form of a \verb|2D| array.
    \item It contains a row buffer to simulate an actual \verb|DRAM|. A row is first copied into this row buffer and the module uses the buffer as a write-back cache for further read and write operations.
\end{itemize}

\section{Approach}

The approach used to simulate the DRAM timing model is described in this section

\subsection{DRAM}
\begin{itemize}
    \item The \verb|DRAM| maintains a \verb|2D| array to simulate the memory and stores a row buffer array to simulate the cache memory.
    \item In case of a \verb|read| operation if the memory address belongs to the row stored in the row buffer, a column access can yield the result.
          However in the other case, the row buffer needs to be written back to the actual memory consuming a time equal to the row delay of DRAM. The new row is loaded into the row buffer and the address is then served from row buffer.
    \item Similar to the above case the \verb|write| operation is implemented which involves writing to the row buffer if the row of the address matches the row stored in buffer else a write back is required.
\end{itemize}

\subsubsection{Advantages}
\begin{itemize}
    \item Abstracting out the \verb|DRAM| methods in a separate module helped modularise the code and an easier implementation of the \verb|lw, sw| instructions
    \item The row buffer in \verb|DRAM| helps to reduce the access time of memory addresses by caching an entire row. This reduces the access time of nearby memory addresses.
    \item Implementing \verb|DRAM| in the form of a \verb|2D| array was necessary to implement a cache mechanism. Storing the data in a linear fashion increases the undecidability in the data to be cached for better performance.
\end{itemize}

\subsubsection{Disadvantages}
\begin{itemize}
    \item When several distant memory addresses in \verb|DRAM| are accessed consecutively it leads to an additional overhead of writing back the memory buffer and reloading it with a fresh row.
          Lots of cache misses can cause the implementation to be slower than a standard no cache implementation.
    \item Copying a row into a row buffer seems like an unnecessary overhead as \verb|C++| already provides constant time random access to any element of the \verb|2D| array.
          Although random access in a \verb|2D| array could speed up our simulator significantly but it would foreshadow the actual hardware implementation of the \verb|DRAM|.
\end{itemize}

\subsection{Non Blocking processor}
A non blocking processor is one that does not block on data that requires a bus read/write. In this case the \verb|lw, sw| instructions
are responsible for storing and loading from the main memory(\verb|DRAM|). This involves a data transfer over the bus and the processor need not block on
bus operation to complete if next instructions do not involve bus access.
\begin{itemize}
    \item When data is loaded/stored from/to the main memory the processor always attempts to execute the next instruction in the cycle immediately following the issue of a DRAM request
    \item If the next instruction does not involve any register used in the \verb|lw, sw| instructions, the instruction is executed.
    \item If the next instruction is itself a \verb|lw, sw| instruction the processor blocks until the previous bus transfer is complete, irrespective of the registers and memory addresses involved.
    \item If the next instruction involves a register that is to be loaded from the memory, the processor blocks, waiting for the bus transfer to complete.
    \item However if the register was simply used to store a value into the main memory; it is not necessary to block, the processor continues execution.
\end{itemize}

\subsubsection{Advantages}
\begin{itemize}
    \item A non blocking processor reduces the number of clock cycles required to execute a set of instructions thus reducing the average \verb|CPI|.
          Instructions that require a bus transfer are executed in parallel and instructions that are not relevant to the bus transfer are executed in the immediately next clock cycle.
    \item The non blocking processor is very efficient for programs that consist majorly of register computations and less frequent bus transfers. This approach can convert the bus transfer instructions that take multiple clock cycles to execute into instructions that execute in a single clock cycle.
    \item The processor blocks on instructions that use registers to be loaded from a pending \verb|lw| call. This ensures that the program output is same as expected if the program was executed completely sequentially.
    \item The optimization introduced to not block on register used as the source of \verb|sw| instruction also reduces unnecessary blocking of the processor.
    \item The approach can never be slower than a sequential program, i.e. there are no additional overheads introduced in the implementation.
\end{itemize}

\subsubsection{Disadvantages}
\begin{itemize}
    \item The approach is equivalent to a sequential program in case several \verb|lw, sw| instructions are executed one after the other.
    \item The approach does not group consecutive \verb|lw, sw| instructions that are unrelated to each other as a single parallel instruction, instead it waits for each one of them to complete before the following instructions can be executed.
    \item A further optimization could be introduced where a register is consecutively loaded from \verb|lw| instruction and a register operation. In such a case the \verb|lw| instruction could be eliminated completely as the immediately following instruction overwrites any value loaded from the memory thus introducing unnecessary overheads.
    \item The memory accesses could be rearranged whenever possible to always access the most nearby address thus reducing the additional overheads incurred by cache misses in \verb|DRAM|. This could involve reordering of certain instructions that are not related to each other and any other instruction in between.
\end{itemize}

\section{Testing}

The testing method was completely manual. The test cases written manually are included in the \verb|./tests| directory. The test cases were run with different parameters
of the program and the outcomes were compared.
\begin{itemize}
    \item \verb|load_and_store.in| : This test case includes consecutive load and store instructions with different offsets to test the correctness of the \verb|DRAM| implementation.
    \item \verb|load_and_use.in| : This test case loads a value from the memory and uses it in the next instruction. This tests whether the program blocks for pending load instruction when a register is to be used.
    \item \verb|load_continuous.in| : This test case was designed to execute \verb|lw| instructions in a single clock cycle. This test case invloves multiple unrlated arithmetic operations after a load instruction. This test cases whether the program does not block when not necessary.
    \item \verb|store_and_use.in| : This test case stores value from a register to the main memory and then uses it in the next operation. Here no blocking is required and the register value is safe to use without blocking for \verb|sw| to complete.
    \item \verb|store_continuous.in| : This test cases executes multiple arithmetic operations after each \verb|sw| instruction and checks wheter \verb|sw| are executed in a single clock cycle.
\end{itemize}

\subsection{Result}
The program output was observed and all the register, memory and row buffer values were inspected for correctness manually. In each of the test case the expected outputs matched. The program blocked when necessary and executed parallely when blocking was not required.

\section{Assumptions}
\begin{itemize}
    \item We have assumed that the maximum memory available to any user program is $2^{20}$ bytes. This does not include the memory required for storing instructions.
    \item We have assumed 32 registers for MIPS each of them storing 32 bits. We have hardwired the register \verb|$0| to the value $0$ as is the case in MIPS hardware. We have also restricted use of kernel reserved registers \verb|$26, $27|.
    \item We have assumed that exactly 1 clock cycle is required for each of the instructions except \verb|lw, sw| to display the execution statistics.
    \item We have enforced tight syntax rules to enforce good coding practice. We disallow certain instructions like (a) \verb|lw $5, ($29)| and (b) \verb|lw $5, 40231|.
          The first instruction skips supplying the offset to the register and the second one involves raw memory access.
    \item Our implementation also enforces using numeric registers instead of their named counterparts. For example \verb|$5| is allowed but its named counterpart \verb|$a1| is disallowed
    \item We have enforced the use of a whitespace between the operand and its arguments. For example \verb|add$4,$5,$6| is disallowed as there is no whitespace between \verb|add| and \verb|$4|
    \item We have implemented branching instructions like \verb|beq, bne, j| to take only labels and instruction numbers as the last argument.
\end{itemize}

\end{document}

