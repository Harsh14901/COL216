\documentclass[hidelinks,12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{float}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
}

\pagestyle{fancy}
\fancyhf{}
\chead{MIPS simulator with DRAM timing model}
\rfoot{\thepage}

\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[scale=0.5]{../../logo.png}\\[1.0cm]
    \Large INDIAN INSTITUTE OF TECHNOLOGY DELHI\\[1.0 cm]
    \LARGE COL216\\[0.1cm]
    \Large \underline{Report}\\
    \large \[Minor\]
    \LARGE \textbf{MIPS simulator with DRAM timing model}


    \rule{\textwidth}{0.2 mm} \\[0.1cm]
    \begin{abstract}
        A simulator is a software that emulates the actions of an entity without actually utilising the entity.
        Here we attempt to create a cross platform MIPS simulator that emulates all the hardware instructions supported by MIPS.
        This simulator takes as input a MIPS assembly program that translates it into instructions executed by MIPS.
        \\[0.1cm]
    \end{abstract}
    \rule{\textwidth}{0.2 mm} \\[0.1cm]
    \begin{flushright}

        \begin{tabular}{c|c}
            \small {Harsh Agrawal} & \small {2019CS10431} \\
        \end{tabular}
    \end{flushright}
\end{titlepage}
\tableofcontents
\newpage

\section{Modules}
We implemented a simulator in \verb|C++| for executing MIPS instructions from assembly code. The program was divided into \verb|compiler| ,\verb|hardware|, and a \verb|DRAM| module.
These modules perform different functions as outlined below
\subsection{Compiler}
\begin{itemize}
    \item This module takes as input the assembly program and parses the tokens according to the syntax specifications of MIPS assembly programs.
    \item This module assembles the program into a sequence of instructions that can be executed according to the hardware specifications.
    \item It also generates appropriate syntax errors if an erreneous expression or an unidentified token is encountered.
    \item The compiler checks the encodibility of instructions into 4 bytes (without actually encoding it) using the size of operands involved.
\end{itemize}
\subsection{Hardware}
\begin{itemize}
    \item This module emulates a subset of instructions provided by MIPS. They are \verb|add, mul, sub, slt, addi, bne, beq, j, lw, sw|.
    \item The module maintains a record of all the register and memory values and modifies them according to the instruction specifications.
    \item It generates appropriate exceptions on performing prohibited actions like out of bounds memory access and reserved register access.
\end{itemize}

\subsection{DRAM}
\begin{itemize}
    \item This module implements the DRAM model in the form of a \verb|2D| array.
    \item It contains a row buffer to simulate an actual \verb|DRAM|. A row is first copied into this row buffer and the module uses the buffer as a write-back cache for further read and write operations.
\end{itemize}

\section{Approach}

The approach used to simulate the DRAM timing model is described in this section

\subsection{DRAM}
\begin{itemize}
    \item The \verb|DRAM| maintains a \verb|2D| array to simulate the memory and stores a row buffer array to simulate the cache memory.
    \item In case of a \verb|read| operation if the memory address belongs to the row stored in the row buffer, a column access can yield the result.
          However in the other case, the row buffer needs to be written back to the actual memory consuming a time equal to the row delay of DRAM. The new row is loaded into the row buffer and the address is then served from row buffer using column access.
    \item Similarly, the \verb|write| operation involves writing to the row buffer if the row of the address matches the row-buffer else a write back is required.
\end{itemize}

\subsubsection{Advantages}
\begin{itemize}
    \item Abstracting out the \verb|DRAM| methods in a separate module helped modularise the code and an easier implementation of the \verb|lw, sw| instructions
    \item The row buffer in \verb|DRAM| helps to reduce the access time of memory addresses by caching an entire row. This reduces the time taken to access nearby memory addresses consecutively.
    \item Implementing \verb|DRAM| in the form of a \verb|2D| array helped implement a cache mechanism. Storing the data linearly increases the complexity by deciding on the appropriate data to be cached for better performance.
\end{itemize}
\subsubsection{Disadvantages}
\begin{itemize}
    \item Access of several distant memory addresses consecutively leads to an additional overhead of writing back the memory buffer and reloading it with a fresh row.
          Lots of cache misses can cause the implementation to be slower than a standard no-cache implementation.
    \item Copying a row into a row buffer seems like an unnecessary overhead as \verb|C++| already provides constant time random access to any element of the \verb|2D| array.
          Although random access in a \verb|2D| array could speed up our simulator significantly but it would foreshadow the actual hardware implementation of the \verb|DRAM|.
    \item The row buffer implemented as a write back cache does not include a dirty bit for the cache. If the dirty bit is unset the DRAM can skip writing back the row buffer to memory.
\end{itemize}

\subsection{Non Blocking processor}
A non blocking processor does not block on data that requires a bus read/write. In this case the \verb|lw, sw| instructions
are responsible for storing and loading from the main memory(\verb|DRAM|). This involves a data transfer over the bus and the processor need not block on
bus operation to execute instructions that only require register computations.
\subsubsection{Specifications}
\begin{itemize}
    \item When data is loaded/stored from/to the main memory the processor always attempts to execute the next instruction in the cycle immediately following the issue of a DRAM request
    \item If the next instruction does not involve any register used in the \verb|lw, sw| instructions, the instruction is safely executed.
    \item If the next instruction is itself a \verb|lw, sw| instruction the processor blocks until the previous bus transfer is complete, irrespective of the registers and memory addresses involved.
    \item If the next instruction involves a register that is to be loaded from the memory, the processor blocks, waiting for the bus transfer to complete.
    \item However if the register was simply used to store a value into the main memory; it is not necessary to block, the processor continues execution.
\end{itemize}

\subsubsection{Advantages}
\begin{itemize}
    \item A non blocking processor reduces the number of clock cycles to execute a set of instructions, reducing the average \verb|CPI|.
          Instructions invloving a bus transfer do not block enabling other instructions to be executed.
    \item The non blocking processor is very efficient for programs that consist majorly of register computations and less frequent bus transfers. It allows execution of \verb|lw, sw| instructions in a single clock cycle which would otherwise consume large clock cycles in blocking mode.
    \item The processor blocks on instructions that use registers to be loaded from a pending \verb|lw| call. This ensures that the program output matches with a program executed in blocking mode.
    \item The optimization to not block on register used as the source of \verb|sw| instruction reduces unnecessary blocking of the processor.
    \item The approach can never be slower than a blocking program, i.e. there are no additional overheads introduced in the implementation.
\end{itemize}

\subsubsection{Disadvantages}
\begin{itemize}
    \item The approach is equivalent to a blocking program in case several \verb|lw, sw| instructions are executed consecutively.
    \item The approach does not group consecutive \verb|lw, sw| instructions that are unrelated to each other as a single parallel instruction, instead it waits for each one of them to complete before the next can be executed.
    \item A further optimization could help in case a register is consecutively loaded from \verb|lw| instruction followed by a register operation. The \verb|lw| instruction could be eliminated completely as the next register operation overwrites any value loaded from the memory.
    \item The memory accesses could be rearranged to always access the most nearby address thus reducing the additional overheads incurred by cache misses in \verb|DRAM|. This involves reordering of unrelated instructions.
\end{itemize}

\section{Testing}

The testing method was completely manual. The test cases written manually are included in the \verb|./tests/input| directory. The test cases were run with different parameters
of the program and the outcomes were compared.
\begin{itemize}
    \item \verb|load_and_store.in| : This test case includes consecutive load and store instructions with different offsets to test the correctness of the \verb|DRAM| implementation.
    \item \verb|load_and_use.in| : This test case loads a value from the memory and uses it in the next instruction. This tests whether the program blocks for pending load instruction when a register is to be used.
    \item \verb|load_continuous.in| : This test case was designed to execute \verb|lw| instructions in a single clock cycle. This test case invloves multiple unrlated arithmetic operations after a load instruction. This test cases whether the program does not block when not necessary.
    \item \verb|store_and_use.in| : This test case stores value from a register to the main memory and then uses it in the next operation. Here no blocking is required and the register value is safe to use without blocking for \verb|sw| to complete.
    \item \verb|store_continuous.in| : This test cases executes multiple arithmetic operations after each \verb|sw| instruction and checks wheter \verb|sw| are executed in a single clock cycle.
\end{itemize}

\subsection{Result}
The program output was observed and all the register, memory and row buffer values were inspected for correctness manually. In each of the test case the expected outputs matched. The program blocked when necessary and executed parallely when blocking was not required.\\[0.2cm]
The output logs of the test cases are available in the \verb|./tests/output| directory. The test cases were run with different configuration options and each test case's blocking and non blocking version is included.

\section{Assumptions}
\begin{itemize}
    \item We have assumed that the maximum memory available to any user program is $2^{20}$ bytes. This does not include the memory required for storing instructions.
    \item We have assumed 32 registers for MIPS each of them storing 32 bits. We have hardwired the register \verb|$0| to the value $0$ as is the case in MIPS hardware. We have also restricted use of kernel reserved registers \verb|$26, $27|.
    \item We have assumed that exactly 1 clock cycle is required for each of the instructions except \verb|lw, sw| to display the execution statistics.
    \item We have enforced tight syntax rules to enforce good coding practice. We disallow certain instructions like (a) \verb|lw $5, ($29)| and (b) \verb|lw $5, 40231|.
          The first instruction skips supplying the offset to the register and the second one involves raw memory access.
    \item Our implementation also enforces using numeric registers instead of their named counterparts. For example \verb|$5| is allowed but its named counterpart \verb|$a1| is disallowed
    \item We have enforced the use of a whitespace between the operand and its arguments. For example \verb|add$4,$5,$6| is disallowed as there is no whitespace between \verb|add| and \verb|$4|
    \item We have implemented branching instructions like \verb|beq, bne, j| to take only labels and instruction numbers as the last argument.
\end{itemize}

\end{document}

