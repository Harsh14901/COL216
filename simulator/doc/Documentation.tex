\documentclass[hidelinks,12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{float}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
}

\pagestyle{fancy}
\fancyhf{}
\chead{Memory Request Ordering}
\rfoot{\thepage}

\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[scale=0.5]{../../logo.png}\\[1.0cm]
    \Large INDIAN INSTITUTE OF TECHNOLOGY DELHI\\[1.0 cm]
    \LARGE COL216\\[0.1cm]
    \Large \underline{Report}\\
    \large \[Assignment-4\]
    \LARGE \textbf{Memory Request Ordering}


    \rule{\textwidth}{0.2 mm} \\[0.1cm]
    \begin{abstract}
        A simulator is a software that emulates the actions of an entity without actually utilising the entity.
        Here we attempt to create a cross platform MIPS simulator that emulates all the hardware instructions supported by MIPS.
        This simulator takes as input a MIPS assembly program that translates it into instructions executed by MIPS.
        \\[0.1cm]
    \end{abstract}
    \rule{\textwidth}{0.2 mm} \\[0.1cm]
    \begin{flushright}

        \begin{tabular}{c|c}
            \small {Harsh Agrawal}      & \small {2019CS10431} \\
            \small {Saptarshi Dasgupta} & \small {2019CS50447} \\
        \end{tabular}
    \end{flushright}
\end{titlepage}
\tableofcontents
\newpage

\section{Modules}
We implemented a simulator in \verb|C++| for executing MIPS instructions from assembly code. The program was divided into \verb|compiler| ,\verb|hardware|, \verb|DRAM| and a \verb|DramDriver| module.
These modules perform different functions as outlined below
\subsection{Compiler}
\begin{itemize}
    \item This module takes as input the assembly program and parses the tokens according to the syntax specifications of MIPS assembly programs.
    \item This module assembles the program into a sequence of instructions that can be executed according to the hardware specifications.
    \item It also generates appropriate syntax errors if an erreneous expression or an unidentified token is encountered.
    \item The compiler checks the encodibility of instructions into 4 bytes (without actually encoding it) using the size of operands involved.
\end{itemize}
\subsection{Hardware}
\begin{itemize}
    \item This module emulates a subset of instructions provided by MIPS. They are \verb|add, mul, sub, slt, addi, bne, beq, j, lw, sw|.
    \item The module maintains a record of all the register and memory values and modifies them according to the instruction specifications.
    \item It generates appropriate exceptions on performing prohibited actions like out of bounds memory access and reserved register access.
\end{itemize}

\subsection{DRAM}
\begin{itemize}
    \item This module implements the DRAM model in the form of a \verb|2D| array.
    \item It contains a row buffer to simulate an actual \verb|DRAM|. A row is first copied into this row buffer and the module uses the buffer as a write-back cache for further read and write operations.
\end{itemize}

\subsection{DramDriver}
\begin{itemize}
    \item A \verb|DramDriver| module is implemented to capture all \verb|DRAM| requests and order them in a queue according to some pre determined heuristics.
    \item The driver recieves the requests from hardware and issues them to \verb|DRAM| in a particular order to maximize clock cycle utilization.
    \item The hardware can also send a blocking call to the driver instructing it to execute all requests until a certain condition is met.
\end{itemize}

\section{Approach}

The approach used to simulate the DRAM memory reordering is described in this section
\begin{itemize}
    \item The \verb|DramDriver| orders the memory requests to minimize the number of row buffer reloads required. Our approach orders the requests of the same row together and another row is chosen only when there is no more request of a given row.
    \item To ensure correctness we have not changed the order of requests of the same address. This ensures that requests of a particular address are always issued in the same order as they were executed by the processor.
    \item The driver also supports blocking on a particular register value. This blocks the processor and instructs the driver to complete all requests pending for the blocking register.
    \item The DRAM requests are issued asynchronously and the processor always executes in non blocking mode, since reordering of requests is not possible in blocking mode.
    \item An optimization was introduced that allowed the driver to overwrite multiple requests for the same address. For example if there are two consecutive write requests to a particular memory address then the first request is deleted provided the same memory address was not used to load another register in between.
    \item Similarly when two consecutive read requests are issued for the same register consecutively, the first request is delted provided the register was not used in between for any instruction.
    \item Another optimization is introduced which selects the next batch of requests after all requests on a row are exhausted depending on the blocking registers involved in each batch. The batch with a blocking register is preferred and executed first.
\end{itemize}

\subsection{Advantages}
\begin{itemize}
    \item The approach ensures that the number of row buffer reloads required is minimized, to reduce the overhead of writing back and loading the row buffer.
    \item The approach always ensures it is not slower than no reordering. We have also maintained correctness by preventing reordering in cases where reordering can yield incorrect results.
    \item The asynchronous nature of DRAM requests allows us to exploit the non blocking functionality of the processor and DRAM thus reducing the clock cycle times required for execution of a program.
    \item The optimizations to replace requests pertaining to the same addresses or registers eliminate redundant requests thus further reducing the runtime without affecting the correctness.
    \item The optimization to select the next batch of request based on the blocking registers helps to reduce the delay of processor clock cycles when a blocking register is encountered.
\end{itemize}
\subsection{Disadvantages}
\begin{itemize}
    \item The reordering can cause processor to block for certain requests that are irrelevant to the blocking instruction. This results in a tradeoff between the DRAM row buffer access time and processor blocked time.
    \item While selecting the appropriate batch of requests for a given row we select it based on the blocking registers involved in each batch. However this may/may not result in an efficient execution workflow for every program as illustrated in one of our test cases.
\end{itemize}
\section{Testing}

The testing method was completely manual. The test cases written manually are included in the \verb|./tests/input| directory. The test cases were run with different parameters
of the program and the outcomes were compared.
\begin{itemize}
    \item \verb|alternate_load_store.txt| : This test case includes alternate load and store instructions with different offsets to test the correctness of the \verb|DRAM| implementation.
    \item \verb|lw_hell.txt| : This test case loads multiple values from the memory in the same register. This tests our optimization of deleting previous requests when same register is involved.
    \item \verb|sw_hell.txt| : This test case stores multiple values into the memory in the same address. This tests our optimization of deleting previous requests when same address is involved.
    \item \verb|multiple_sw.txt| : This file tests elimination of redundant instructions that involve the same address and the same register.
    \item \verb|choosing_batch.txt| : This file tests our second optimization of choosing the batch of requests based on the blocking registers involved.
    \item \verb|memory_skips.txt|: This test case issues multiple read/write requests to the driver with each successive request differing in the row of the address involved. This tests the reordering of the requests in the appropriate manner to reduce row buffer reloads.
\end{itemize}

\subsection{Result}
The program output was observed and all the register, memory and row buffer values were inspected for correctness manually. In each of the test case the expected outputs matched. The program blocked when necessary and executed parallely when blocking was not required.\\[0.2cm]
The output logs of the test cases are available in the \verb|./tests/output| directory. The test cases were run with different configuration options.

\section{Assumptions}
\begin{itemize}
    \item We have assumed that the maximum memory available to any user program is $2^{20}$ bytes. This does not include the memory required for storing instructions.
    \item We have assumed 32 registers for MIPS each of them storing 32 bits. We have hardwired the register \verb|$zero| to the value $0$ as is the case in MIPS hardware. We have also restricted use of kernel reserved registers \verb|$26, $27|.
    \item We have assumed that exactly 1 clock cycle is required for each of the instructions except \verb|lw, sw| to display the execution statistics.
    \item We have enforced tight syntax rules to enforce good coding practice. We disallow certain instructions like (a) \verb|lw $t1, ($sp)| and (b) \verb|lw $t1, 40231|.
          The first instruction skips supplying the offset to the register and the second one involves raw memory access.
    \item We have enforced the use of a whitespace between the operand and its arguments. For example \verb|add$t1,$t2,$t3| is disallowed as there is no whitespace between \verb|add| and \verb|$t1|
    \item We have implemented branching instructions like \verb|beq, bne, j| to take only labels and instruction numbers as the last argument.
\end{itemize}

\end{document}

